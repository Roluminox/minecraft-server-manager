/**
 * Environment file (.env) manager
 * Read, write, and update .env files
 */

const fs = require('fs').promises;

class EnvManager {
  /**
   * @param {string} envFilePath - Path to .env file
   */
  constructor(envFilePath) {
    this.envFilePath = envFilePath;
    this.cache = null;
    this.cacheTime = null;
    this.cacheTTL = 5000; // 5 seconds cache
  }

  /**
   * Read all variables from .env file
   * @param {boolean} useCache - Use cached values if available
   * @returns {Promise<object>}
   */
  async read(useCache = true) {
    // Check cache
    if (useCache && this.cache && this.cacheTime && Date.now() - this.cacheTime < this.cacheTTL) {
      return { ...this.cache };
    }

    try {
      const content = await fs.readFile(this.envFilePath, 'utf8');
      const vars = this._parse(content);

      // Update cache
      this.cache = vars;
      this.cacheTime = Date.now();

      return vars;
    } catch (error) {
      if (error.code === 'ENOENT') {
        return {};
      }
      throw error;
    }
  }

  /**
   * Get a single variable
   * @param {string} key
   * @param {any} defaultValue
   * @returns {Promise<string|null>}
   */
  async get(key, defaultValue = null) {
    const vars = await this.read();
    return vars[key] !== undefined ? vars[key] : defaultValue;
  }

  /**
   * Set a single variable
   * @param {string} key
   * @param {string} value
   * @returns {Promise<void>}
   */
  async set(key, value) {
    const vars = await this.read(false);
    vars[key] = String(value);
    await this.write(vars);
  }

  /**
   * Set multiple variables
   * @param {object} updates
   * @returns {Promise<void>}
   */
  async setMultiple(updates) {
    const vars = await this.read(false);
    for (const [key, value] of Object.entries(updates)) {
      vars[key] = String(value);
    }
    await this.write(vars);
  }

  /**
   * Delete a variable
   * @param {string} key
   * @returns {Promise<void>}
   */
  async delete(key) {
    const vars = await this.read(false);
    delete vars[key];
    await this.write(vars);
  }

  /**
   * Write all variables to .env file
   * @param {object} vars
   * @returns {Promise<void>}
   */
  async write(vars) {
    const content = this._stringify(vars);
    await fs.writeFile(this.envFilePath, content, 'utf8');

    // Update cache
    this.cache = { ...vars };
    this.cacheTime = Date.now();
  }

  /**
   * Check if .env file exists
   * @returns {Promise<boolean>}
   */
  async exists() {
    try {
      await fs.access(this.envFilePath);
      return true;
    } catch {
      return false;
    }
  }

  /**
   * Create .env file with default values
   * @param {object} defaults
   * @returns {Promise<void>}
   */
  async createWithDefaults(defaults) {
    const exists = await this.exists();
    if (!exists) {
      await this.write(defaults);
    }
  }

  /**
   * Invalidate cache
   */
  invalidateCache() {
    this.cache = null;
    this.cacheTime = null;
  }

  // === Parsing ===

  /**
   * Parse .env content into object
   * @param {string} content
   * @returns {object}
   */
  _parse(content) {
    const vars = {};
    const lines = content.split('\n');

    for (const line of lines) {
      // Skip empty lines and comments
      const trimmed = line.trim();
      if (!trimmed || trimmed.startsWith('#')) {
        continue;
      }

      // Find first = sign
      const eqIndex = trimmed.indexOf('=');
      if (eqIndex === -1) {
        continue;
      }

      const key = trimmed.substring(0, eqIndex).trim();
      let value = trimmed.substring(eqIndex + 1).trim();

      // Remove surrounding quotes if present
      if ((value.startsWith('"') && value.endsWith('"')) ||
          (value.startsWith("'") && value.endsWith("'"))) {
        value = value.slice(1, -1);
      }

      // Handle escaped characters
      value = value
        .replace(/\\n/g, '\n')
        .replace(/\\r/g, '\r')
        .replace(/\\t/g, '\t');

      vars[key] = value;
    }

    return vars;
  }

  /**
   * Stringify object to .env content
   * @param {object} vars
   * @returns {string}
   */
  _stringify(vars) {
    const lines = [];

    // Add header comment
    lines.push('# Minecraft Server Configuration');
    lines.push('# Generated by Minecraft Server Manager');
    lines.push('');

    // Group variables by prefix
    const groups = this._groupByPrefix(vars);

    for (const [prefix, groupVars] of Object.entries(groups)) {
      if (prefix) {
        lines.push(`# ${prefix.toUpperCase()}`);
      }

      for (const [key, value] of Object.entries(groupVars)) {
        const stringValue = String(value);

        // Quote if contains spaces or special characters
        if (stringValue.includes(' ') || stringValue.includes('#') ||
            stringValue.includes('\n') || stringValue.includes('\r')) {
          lines.push(`${key}="${stringValue.replace(/"/g, '\\"')}"`);
        } else {
          lines.push(`${key}=${stringValue}`);
        }
      }

      lines.push('');
    }

    return lines.join('\n');
  }

  /**
   * Group variables by prefix (before first _)
   * @param {object} vars
   * @returns {object}
   */
  _groupByPrefix(vars) {
    const groups = { '': {} };

    for (const [key, value] of Object.entries(vars)) {
      const underscoreIndex = key.indexOf('_');
      const prefix = underscoreIndex > 0 ? key.substring(0, underscoreIndex) : '';

      if (!groups[prefix]) {
        groups[prefix] = {};
      }

      groups[prefix][key] = value;
    }

    return groups;
  }
}

module.exports = { EnvManager };
